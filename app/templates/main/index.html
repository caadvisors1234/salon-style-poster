{% extends "base.html" %}

{% block title %}スタイル投稿タスク - SALON BOARD Style Poster{% endblock %}

{% block content %}
<div class="card">
    <h2 class="card-header">スタイル投稿タスク</h2>

    <!-- タスク未実行時のフォーム -->
    <div id="task-form-section" class="hidden">
        <form id="task-form">
            <div class="form-group">
                <label for="setting_id" class="form-label">SALON BOARD設定</label>
                <select id="setting_id" name="setting_id" class="form-select" required>
                    <option value="">設定を選択してください</option>
                </select>
                <span class="form-hint">
                    設定がない場合は「設定」ページから追加してください
                </span>
            </div>

            <!-- D&D対応ファイルアップロード -->
            <div class="form-group">
                <div class="d-flex align-items-center mb-2">
                    <label class="form-label fw-bold mb-0 me-2">スタイル情報ファイル (CSV/Excel)</label>
                    <a href="#" class="text-secondary" onclick="toggleTemplateExample(event)" title="テンプレート形式の例を表示"
                        style="text-decoration: none;">
                        <i class="bi bi-question-circle-fill fs-5"></i>
                    </a>
                </div>

                <div id="template-example" class="template-example hidden mb-3">
                    <div class="card card-body bg-light p-3">
                        <p class="mb-2 small">以下のカラムを持つCSVまたはExcelファイルを作成してください。</p>
                        <div class="table-responsive">
                            <table class="table table-sm table-bordered bg-white small mb-0" style="min-width: 800px;">
                                <thead class="table-light">
                                    <tr>
                                        <th>スタイリスト名</th>
                                        <th>クーポン名</th>
                                        <th>コメント</th>
                                        <th>スタイル名</th>
                                        <th>カテゴリ</th>
                                        <th>長さ</th>
                                        <th>メニュー内容</th>
                                        <th>ハッシュタグ</th>
                                        <th>画像名</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>山田 花子</td>
                                        <td>【新規】...</td>
                                        <td>春らしい...</td>
                                        <td>春のふんわりボブ</td>
                                        <td>レディース</td>
                                        <td>ミディアム</td>
                                        <td>カット+カラー</td>
                                        <td>春髪, ボブ</td>
                                        <td>spring_bob.jpg</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="mt-2 mb-0 x-small text-muted">※ 「画像名」はアップロードするファイル名と完全に一致させてください。</p>
                    </div>
                </div>

                <div id="drop-zone-data" class="upload-drop-zone">
                    <div class="drop-zone-content">
                        <i class="bi bi-file-earmark-spreadsheet fs-1 text-muted mb-2"></i>
                        <p class="mb-1">ファイルをここにドラッグ＆ドロップ</p>
                        <p class="text-muted small">または</p>
                        <button type="button" class="btn btn-outline-primary btn-sm"
                            onclick="document.getElementById('style_data_file').click()">ファイルを選択</button>
                    </div>
                    <!-- inputは非表示にするが、フォーム送信で必要 -->
                    <input class="form-control d-none" type="file" id="style_data_file" name="style_data_file"
                        accept=".csv, .xlsx" required style="display:none;">
                    <div id="file-name-data" class="mt-2 text-primary fw-bold small"></div>
                </div>

                <span class="form-hint">テンプレート形式に沿ったファイル（.csv, .xlsx）を選択してください。</span>
            </div>

            <div class="form-group">
                <label class="form-label fw-bold">スタイル画像 (複数選択可)</label>
                <div id="drop-zone-images" class="upload-drop-zone">
                    <div class="drop-zone-content">
                        <i class="bi bi-images fs-1 text-muted mb-2"></i>
                        <p class="mb-1">画像ファイルをここにドラッグ＆ドロップ</p>
                        <p class="text-muted small">または</p>
                        <button type="button" class="btn btn-outline-primary btn-sm"
                            onclick="document.getElementById('image_files').click()">ファイルを選択</button>
                    </div>
                    <input class="form-control d-none" type="file" id="image_files" name="image_files" accept="image/*"
                        multiple required style="display:none;">
                </div>
                <div id="preview-area-images" class="image-preview-grid mt-3"></div>
                <span class="form-hint">スタイルデータ内の「画像名」と一致するファイルを選択してください。</span>
            </div>

            <div class="btn-group">
                <button type="submit" class="btn btn-primary">
                    タスクを開始
                </button>
            </div>
        </form>
    </div>

    <!-- タスク実行中の進捗表示 -->
    <div id="task-progress-section" class="hidden">
        <div class="progress-container">
            <div class="progress-bar-wrapper">
                <div id="progress-bar" class="progress-bar progress-bar-striped progress-bar-animated"
                    style="width: 0%">
                    <span id="progress-text">0%</span>
                </div>
            </div>
            <div class="progress-info">
                <span id="progress-items">0 / 0 件完了</span>
                <span id="progress-status">処理中...</span>
            </div>
            <div id="progress-detail" class="progress-detail hidden">
                <div class="progress-detail-header">
                    <span id="progress-stage" class="progress-stage-label"></span>
                    <span id="progress-updated-at" class="progress-detail-timestamp text-muted"></span>
                </div>
                <div id="progress-message" class="progress-detail-message text-muted"></div>
                <div id="progress-style-wrapper" class="progress-style-info hidden">
                    <span class="progress-style-label">スタイル</span>
                    <span id="progress-style-name" class="progress-style-name"></span>
                </div>
            </div>
        </div>

        <!-- エラーサマリー（処理中） -->
        <div id="error-summary-progress" class="error-summary hidden">
            <div class="error-summary-header">
                <span class="error-summary-icon">⚠️</span>
                <span class="error-summary-text">エラー発生中: <span id="error-count-progress"
                        class="error-count">0</span>件</span>
            </div>
        </div>

        <div class="btn-group mt-2">
            <button id="cancel-task-btn" class="btn btn-danger">
                タスクを中止
            </button>
        </div>
    </div>

    <!-- タスク完了時の結果表示 -->
    <div id="task-result-section" class="hidden">
        <div id="success-message" class="alert alert-success hidden">
            タスクが完了しました！
        </div>

        <div id="failure-message" class="alert alert-danger hidden">
            タスクがエラーにより中断されました
        </div>

        <div id="manual-upload-section" class="alert alert-warning hidden">
            <div class="manual-upload-header">
                <h3 class="mt-0 mb-1">手動画像登録のお願い <span id="manual-upload-count" class="badge badge-light">0件</span></h3>
                <p class="mb-1">
                    以下のスタイルについては画像の自動登録が完了しませんでした。SALON BOARD 上で該当画像を手動登録してください。
                </p>
            </div>
            <div class="table-responsive">
                <table class="table manual-upload-table">
                    <thead>
                        <tr>
                            <th scope="col">#</th>
                            <th scope="col">スタイル名</th>
                            <th scope="col">画像ファイル名</th>
                            <th scope="col">対応内容</th>
                        </tr>
                    </thead>
                    <tbody id="manual-upload-list"></tbody>
                </table>
            </div>
        </div>

        <div id="error-report-section" class="hidden">
            <h3 class="mt-2 mb-1">エラーレポート</h3>

            <!-- エラーサマリー（完了時） -->
            <div class="error-summary mb-2">
                <div class="error-summary-header">
                    <span class="error-summary-icon">⚠️</span>
                    <span class="error-summary-text">合計 <span id="error-count-result"
                            class="error-count">0</span>件のエラー</span>
                </div>
            </div>

            <div id="error-list" class="error-list"></div>
        </div>

        <div class="btn-group mt-2">
            <button id="new-task-btn" class="btn btn-primary">
                新しいタスクを開始
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    let pollingInterval = null;
    let currentUser = null;
    let lastErrorCount = 0;
    let notificationPermission = 'default';

    const stageLabelMap = {
        BROWSER_STARTING: 'ブラウザ起動準備',
        BROWSER_READY: 'ブラウザ起動完了',
        LOGIN_COMPLETED: 'ログイン完了',
        DATA_READY: 'データ読み込み完了',
        NAVIGATED: '投稿準備完了',
        STYLE_PROCESSING: 'スタイル処理中',
        STYLE_COMPLETED: 'スタイル処理完了',
        STYLE_ERROR: 'スタイル処理エラー',
        STYLE_WARNING: '手動対応が必要',
        SUMMARY: '処理完了',
        TARGET_READY: '対象確認完了',
        UNPUBLISH_PROCESSING: '非掲載処理中',
        UNPUBLISH_COMPLETED: '非掲載完了',
        UNPUBLISH_ERROR: '非掲載エラー',
        CANCELLING: 'キャンセル処理',
        CANCELLED: 'キャンセル済み',
        FAILED: 'タスク失敗',
        COMPLETED: 'タスク完了'
    };

    function resolveStageLabel(detail) {
        if (!detail) return '';
        if (detail.stage_label) return detail.stage_label;
        if (detail.stage && stageLabelMap[detail.stage]) {
            return stageLabelMap[detail.stage];
        }
        return '進捗情報';
    }

    function formatDetailTimestamp(isoString) {
        if (!isoString) return '';
        const parsed = new Date(isoString);
        if (Number.isNaN(parsed.getTime())) return '';
        return parsed.toLocaleString('ja-JP');
    }

    function deriveStatusLabel(status) {
        if (!status) return '状態取得中...';
        const detailStatus = status.detail?.status;

        if (status.status === 'PROCESSING') {
            if (detailStatus === 'error') return 'エラーを処理中...';
            if (detailStatus === 'working') return '処理中...';
            if (detailStatus === 'info') return '準備中...';
            return '処理中...';
        }

        if (status.status === 'CANCELLING') {
            return '中止要求を処理中...';
        }

        if (status.status === 'SUCCESS') {
            return '完了しました';
        }

        if (status.status === 'FAILURE') {
            if (detailStatus === 'cancelled') {
                return 'ユーザーが中止しました';
            }
            return 'エラーで停止しました';
        }

        return '状態取得中...';
    }

    document.addEventListener('DOMContentLoaded', async () => {
        try {
            currentUser = await apiCall('/api/v1/auth/me');
            await requestNotificationPermission();
            await loadSettings();
            await checkTaskStatus();

            // D&D Setup
            setupDragAndDrop('drop-zone-data', 'style_data_file', 'file-name-data', false);
            setupDragAndDrop('drop-zone-images', 'image_files', 'preview-area-images', true);
        } catch (error) {
            console.error('Initialization error:', error);
            showAlert(error.message, 'danger');
        }
    });

    async function requestNotificationPermission() {
        if ('Notification' in window) {
            notificationPermission = await Notification.requestPermission();
        }
    }

    function sendNotification(title, body, options = {}) {
        if (notificationPermission === 'granted') {
            new Notification(title, {
                body: body,
                icon: '/static/favicon.ico',
                badge: '/static/favicon.ico',
                ...options
            });
        }
    }

    async function loadSettings() {
        try {
            const data = await apiCall('/api/v1/sb-settings/');
            const settings = data.settings || [];
            const select = document.getElementById('setting_id');

            while (select.options.length > 1) {
                select.remove(1);
            }

            if (settings.length === 0) {
                showAlert('SALON BOARD設定が登録されていません。設定ページから登録してください。', 'warning');
            }

            settings.forEach(setting => {
                const option = document.createElement('option');
                option.value = setting.id;
                option.textContent = setting.setting_name;
                select.appendChild(option);
            });
        } catch (error) {
            console.error('Failed to load settings:', error);
        }
    }

    async function checkTaskStatus() {
        try {
            const status = await apiCall('/api/v1/tasks/status');

            if (status.status === 'PROCESSING' || status.status === 'CANCELLING') {
                showProgressSection(status);
                startPolling();
            } else if (status.status === 'SUCCESS' || status.status === 'FAILURE') {
                await showResultSection(status);
            }
        } catch (error) {
            showFormSection();
        }
    }

    function showFormSection() {
        document.getElementById('task-form-section').classList.remove('hidden');
        document.getElementById('task-progress-section').classList.add('hidden');
        document.getElementById('task-result-section').classList.add('hidden');
    }

    function showProgressSection(status) {
        document.getElementById('task-form-section').classList.add('hidden');
        document.getElementById('task-progress-section').classList.remove('hidden');
        document.getElementById('task-result-section').classList.add('hidden');

        const cancelButton = document.getElementById('cancel-task-btn');
        if (cancelButton) {
            cancelButton.disabled = false;
            cancelButton.textContent = 'タスクを中止';
        }

        updateProgress(status);
    }

    async function showResultSection(status) {
        document.getElementById('task-form-section').classList.add('hidden');
        document.getElementById('task-progress-section').classList.add('hidden');
        document.getElementById('task-result-section').classList.remove('hidden');

        const successMessage = document.getElementById('success-message');
        const failureMessage = document.getElementById('failure-message');
        successMessage.classList.add('hidden');
        failureMessage.classList.add('hidden');
        failureMessage.textContent = 'タスクがエラーにより中断されました';

        if (status.status === 'SUCCESS') {
            successMessage.classList.remove('hidden');
        } else if (status.detail?.status === 'cancelled') {
            failureMessage.textContent = 'ユーザー操作によりタスクを中止しました';
            failureMessage.classList.remove('hidden');
        } else {
            failureMessage.classList.remove('hidden');
        }

        if (status.has_errors || (status.manual_upload_count && status.manual_upload_count > 0)) {
            await loadErrorReport();
        } else {
            document.getElementById('error-report-section').classList.add('hidden');
            document.getElementById('manual-upload-section').classList.add('hidden');
        }
    }

    function updateProgress(status) {
        const progress = status.progress;
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const progressItems = document.getElementById('progress-items');
        const progressStatus = document.getElementById('progress-status');
        const progressDetail = document.getElementById('progress-detail');
        const progressStage = document.getElementById('progress-stage');
        const progressUpdatedAt = document.getElementById('progress-updated-at');
        const progressMessage = document.getElementById('progress-message');
        const progressStyleWrapper = document.getElementById('progress-style-wrapper');
        const progressStyleName = document.getElementById('progress-style-name');

        progressBar.style.width = `${progress}%`;
        progressText.textContent = `${progress}%`;
        progressItems.textContent = `${status.completed_items} / ${status.total_items} 件完了`;
        progressStatus.textContent = deriveStatusLabel(status);

        const detail = status.detail;
        if (detail) {
            progressDetail.classList.remove('hidden');
            progressStage.textContent = resolveStageLabel(detail);
            progressMessage.textContent = detail.message || '';
            const timestampText = formatDetailTimestamp(detail.updated_at);
            progressUpdatedAt.textContent = timestampText ? `更新: ${timestampText}` : '';

            if (detail.style_name || detail.style_number) {
                progressStyleWrapper.classList.remove('hidden');
                progressStyleName.textContent = detail.style_name || `番号 ${detail.style_number}`;
            } else {
                progressStyleWrapper.classList.add('hidden');
                progressStyleName.textContent = '';
            }
        } else {
            progressDetail.classList.add('hidden');
            progressStage.textContent = '';
            progressMessage.textContent = '';
            progressUpdatedAt.textContent = '';
            progressStyleWrapper.classList.add('hidden');
            progressStyleName.textContent = '';
        }

        const errorSummaryProgress = document.getElementById('error-summary-progress');
        const errorCountProgress = document.getElementById('error-count-progress');

        if (status.error_count > 0) {
            errorSummaryProgress.classList.remove('hidden');
            errorCountProgress.textContent = status.error_count;

            if (status.error_count > lastErrorCount) {
                const newErrors = status.error_count - lastErrorCount;
                sendNotification(
                    'エラー発生',
                    `${newErrors}件の新しいエラーが発生しました（合計${status.error_count}件）`,
                    { tag: 'task-error' }
                );
            }
            lastErrorCount = status.error_count;
        } else {
            errorSummaryProgress.classList.add('hidden');
        }
    }

    function startPolling() {
        if (pollingInterval) return;

        pollingInterval = setInterval(async () => {
            try {
                const status = await apiCall('/api/v1/tasks/status');

                if (status.status === 'PROCESSING' || status.status === 'CANCELLING') {
                    updateProgress(status);
                } else {
                    stopPolling();
                    lastErrorCount = 0;

                    if (status.status === 'SUCCESS') {
                        sendNotification(
                            'タスク完了',
                            status.has_errors
                                ? `タスクが完了しました（エラー: ${status.error_count}件）`
                                : 'タスクが完了しました',
                            { tag: 'task-complete' }
                        );
                    } else {
                        const isCancelled = status.detail?.status === 'cancelled';
                        sendNotification(
                            isCancelled ? 'タスク中止' : 'タスク失敗',
                            isCancelled ? 'タスクをキャンセルしました' : 'タスクがエラーにより中断されました',
                            { tag: isCancelled ? 'task-cancelled' : 'task-failed' }
                        );
                    }

                    await showResultSection(status);
                }
            } catch (error) {
                console.error('Polling error:', error);
                stopPolling();
            }
        }, 2000);
    }

    function stopPolling() {
        if (pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
        }
    }

    async function loadErrorReport() {
        try {
            const report = await apiCall('/api/v1/tasks/error-report');
            const errorList = document.getElementById('error-list');
            const errorSection = document.getElementById('error-report-section');
            const errorCountResult = document.getElementById('error-count-result');
            const manualSection = document.getElementById('manual-upload-section');
            const manualList = document.getElementById('manual-upload-list');
            const manualCountBadge = document.getElementById('manual-upload-count');

            errorList.innerHTML = '';
            errorCountResult.textContent = report.total_errors;

            manualList.innerHTML = '';
            const manualUploads = report.manual_uploads || [];
            if (manualUploads.length > 0) {
                manualSection.classList.remove('hidden');
                manualCountBadge.textContent = `${manualUploads.length}件`;
                manualUploads.forEach((item, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${item.style_name || '-'}</td>
                        <td>${item.image_name || '-'}</td>
                        <td>${item.reason || ''}</td>
                    `;
                    manualList.appendChild(row);
                });
            } else {
                manualSection.classList.add('hidden');
                manualCountBadge.textContent = '0件';
            }

            const errors = report.errors || [];
            if (errors.length > 0) {
                errors.forEach((error, index) => {
                    const errorItem = document.createElement('div');
                    errorItem.className = 'error-item';

                    const screenshotHtml = error.screenshot_url ? `
                        <div class="error-screenshot">
                            <strong>スクリーンショット:</strong>
                            <div class="screenshot-thumbnail-container">
                                <img
                                    src="${error.screenshot_url}"
                                    alt="Error screenshot"
                                    class="screenshot-thumbnail"
                                    onclick="openScreenshotModal('${error.screenshot_url}')"
                                >
                                <div class="screenshot-overlay">クリックで拡大</div>
                            </div>
                        </div>
                    ` : '';

                    errorItem.innerHTML = `
                        <div class="error-item-header">
                            <span class="error-number">エラー ${index + 1}</span>
                            <span class="error-row">行 ${error.row_number}</span>
                            <span class="error-style-name">${error.style_name}</span>
                        </div>
                        <div class="error-item-details">
                            <div class="error-field">
                                <strong>項目:</strong> ${error.field}
                            </div>
                            <div class="error-reason">
                                <strong>理由:</strong> ${error.reason}
                            </div>
                            ${screenshotHtml}
                        </div>
                    `;
                    errorList.appendChild(errorItem);
                });
                errorSection.classList.remove('hidden');
            } else {
                errorSection.classList.add('hidden');
            }
        } catch (error) {
            console.error('Failed to load error report:', error);
        }
    }

    function openScreenshotModal(imageUrl) {
        const modal = document.createElement('div');
        modal.className = 'screenshot-modal';
        modal.innerHTML = `
            <div class="screenshot-modal-content">
                <span class="screenshot-modal-close">&times;</span>
                <img src="${imageUrl}" alt="Screenshot" class="screenshot-modal-image">
            </div>
        `;

        document.body.appendChild(modal);

        const closeBtn = modal.querySelector('.screenshot-modal-close');
        closeBtn.onclick = () => {
            document.body.removeChild(modal);
        };

        modal.onclick = (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        };

        const escHandler = (e) => {
            if (e.key === 'Escape') {
                document.body.removeChild(modal);
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
    }

    document.getElementById('task-form').addEventListener('submit', async (e) => {
        e.preventDefault();

        const formData = new FormData(e.target);

        showLoading();

        try {
            await apiCallFormData('/api/v1/tasks/style-post', formData);

            hideLoading();
            showAlert('タスクを開始しました', 'success');

            await checkTaskStatus();
        } catch (error) {
            hideLoading();
            showAlert(error.message, 'danger');
        }
    });

    document.getElementById('cancel-task-btn').addEventListener('click', async (event) => {
        const cancelButton = event.currentTarget;
        const originalText = cancelButton.textContent;

        if (!confirm('本当にタスクを即座に中止しますか？\n実行中の処理は強制終了されます。')) {
            return;
        }

        cancelButton.disabled = true;
        cancelButton.textContent = '中止リクエスト送信中...';

        try {
            await apiCall('/api/v1/tasks/cancel', { method: 'POST' });
            showAlert('タスクの中止を要求しました', 'info');
            await checkTaskStatus();
        } catch (error) {
            showAlert(error.message, 'danger');
        } finally {
            cancelButton.disabled = false;
            cancelButton.textContent = originalText;
        }
    });

    document.getElementById('new-task-btn').addEventListener('click', async () => {
        try {
            await apiCall('/api/v1/tasks/finished-task', { method: 'DELETE' });
            showFormSection();
            document.getElementById('task-form').reset();
            // プレビューもリセット
            document.getElementById('file-name-data').textContent = '';
            document.getElementById('preview-area-images').innerHTML = '';
        } catch (error) {
            showAlert(error.message, 'danger');
        }
    });

    // --- Drag & Drop Utils ---
    function setupDragAndDrop(dropZoneId, inputId, previewId, isMultiple) {
        const dropZone = document.getElementById(dropZoneId);
        const input = document.getElementById(inputId);
        if (!dropZone || !input) return;

        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        // Highlight drop zone when item is dragged over it
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, unhighlight, false);
        });

        // Handle dropped files
        dropZone.addEventListener('drop', handleDrop, false);

        // Handle file selection via input
        input.addEventListener('change', function () {
            handleFiles(this.files);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function highlight(e) {
            dropZone.classList.add('dragover');
        }

        function unhighlight(e) {
            dropZone.classList.remove('dragover');
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                const dataTransfer = new DataTransfer();
                if (isMultiple) {
                    // 複数選択の場合、既存の選択済みファイルに追加するロジックも考えられるが、
                    // ここではシンプルに新規セット（置換）する動作とする
                    // 既存ファイルに追加したい場合は input.files を読み込んで結合する必要があるが、
                    // input.files は読み取り専用のため DataTransfer を再構築する必要がある
                    Array.from(files).forEach(file => dataTransfer.items.add(file));
                } else {
                    dataTransfer.items.add(files[0]);
                }

                // input.files にセット
                input.files = dataTransfer.files;

                // プレビュー更新
                handleFiles(files);
            }
        }

        function handleFiles(files) {
            const previewArea = document.getElementById(previewId);
            previewArea.innerHTML = '';

            if (!files || files.length === 0) return;

            if (isMultiple) {
                // 画像プレビュー
                let imageCount = 0;
                Array.from(files).forEach(file => {
                    if (file.type.startsWith('image/')) {
                        imageCount++;
                        // パフォーマンスのため、大量のファイルのプレビューは制限するか、軽量化する
                        // ここではシンプルに実装
                        const reader = new FileReader();
                        reader.readAsDataURL(file);
                        reader.onloadend = function () {
                            const div = document.createElement('div');
                            div.className = 'preview-item';
                            div.innerHTML = `
                                      <img src="${reader.result}" alt="${file.name}">
                                      <div class="preview-item-name">${file.name}</div>
                                 `;
                            previewArea.appendChild(div);
                        }
                    }
                });
                if (imageCount === 0 && files.length > 0) {
                    previewArea.textContent = `${files.length}個のファイルを選択中（画像なし）`;
                }
            } else {
                // 単一ファイル（データファイル）
                if (files.length > 0) {
                    const file = files[0];
                    previewArea.textContent = `選択中: ${file.name} (${formatBytes(file.size)})`;
                }
            }
        }
    }

    function formatBytes(bytes, decimals = 2) {
        if (!+bytes) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
    }

    function toggleTemplateExample(e) {
        e.preventDefault();
        const example = document.getElementById('template-example');
        example.classList.toggle('hidden');
    }
</script>
{% endblock %}